# SPEC: Planning Backends & Profiles (Draft v0.1)

**Repository:** Hyperprompt (и любые репозитории, принимающие этот spec)  
**Status:** Draft  
**Audience:** maintainers, contributors, agent-runners, tooling authors  
**Goal:** заложить “эластичность планирования”: поддержать разные стили и фреймворки (в т.ч. Beads) без потери offline-first source of truth и без деградации безопасности/аудита.

---

## 1. Декларация намерений

Люди и команды планируют по-разному: Scrum, Kanban, “список в Markdown”, граф задач, личные фреймворки, агентские “memory systems”.

Этот spec вводит абстракции, которые позволяют:

- сохранить **один каноничный источник правды** по требованиям и задачам (offline-first),
- подключать дополнительные “планирующие” системы как **зеркала** (mirrors),
- дать агентам и тулзам единый минимальный язык (Task Core Schema),
- формально описывать стиль планирования (Planning Profile) так, чтобы разные репозитории и команды были совместимы.

---

## 2. Термины

**Planning Backend** — система/формат, в котором представлен backlog/план (файл, граф, внешний сервис).  
**Canonical Backend** — единственный backend, считающийся source of truth для требований и постановки задач.  
**Mirror Backend** — производная проекция (mirror) каноничного плана, используемая для удобства исполнения/навигации.  
**Planning Profile** — декларация стиля и ожиданий: Definition of Ready/Done, требования к AC/DoD, типы задач, риск-теги.

---

## 3. Требование единого источника правды

Репозиторий обязан выбрать **ровно один** Canonical Backend.

- Все изменения постановки и требований происходят **только** через каноничный backend (обычно через PR в репозиторий).
- Любой mirror backend считается “кешем/проекцией” и не может быть источником требований.

Это правило защищает от “двух редакторов правды” и от подмены постановки агентом.

---

## 4. Task Core Schema (минимальное ядро задачи)

Все backends (canonical и mirrors) должны быть способны представить следующие поля.

### 4.1. Обязательные поля

- `task_id` — стабильный уникальный ID
- `title` — краткое название
- `state` — минимум: `draft|ready|blocked|done` (расширяемо)
- `priority` — число или enum
- `deps[]` — список зависимостей по `task_id` (может быть пустым)
- `source_ref` — ссылка/якорь на каноничную постановку (для mirrors)

### 4.2. Рекомендуемые поля

- `stage` — фаза/эпик/группа
- `acceptance[]` — acceptance criteria
- `dod[]` — definition of done
- `tags[]` — теги возможностей/рисков
- `owner_hint` — например `needs-maintainer`, `maintainer-only`
- `notes` — краткие пояснения

### 4.3. Расширения

Любые дополнительные поля допускаются, если:
- они не меняют смысла Task Core полей,
- они сериализуемы и стабильны,
- они не используются как единственный носитель требований (требования должны ссылаться на canonical).

Рекомендуемый префикс для нестандартных полей: `x_...` или `X-...`.

---

## 5. Planning Profile (стиль планирования)

Planning Profile описывает “как мы планируем здесь”. Он должен быть формализован и храниться в репозитории (например, `DOCS/PLANNING_PROFILE.md` или `DOCS/PLANNING_PROFILE.yml`).

### 5.1. Минимальные параметры

- `profile_name`: `light|standard|strict` (или своё имя)
- `definition_of_ready`: требования к задаче для статуса `ready`
- `definition_of_done`: требования к завершению (обычно merge + обновления)
- `ai_ready_criteria`: критерии для `agent-ready` (если используется)
- `task_types`: список типов задач (feature/bug/refactor/docs/perf/research…)
- `risk_tags`: список риск-тегов (needs-maintainer, api-change, security-sensitive…)

### 5.2. Рекомендация по профилям

**light** — минимальный процесс: title + state + verification ссылки.  
**standard** — AC или ссылка на PRD + deps + ограничения.  
**strict** — AC + DoD + строгий diff coverage + отдельные гейты для judge/spec changes.

---

## 6. Backend Registry (объявление backends)

Репозиторий должен объявить, какие backends используются, и какой из них каноничный.

Рекомендуемый файл: `DOCS/PLANNING_BACKENDS.yml`.

Минимальная структура:

- `canonical`: идентификатор backend (например `markdown-workplan`)
- `backends[]`: список backends с параметрами
- `mirrors[]`: список зеркал и правил синхронизации

---

## 7. Backend: markdown-workplan (каноничный)

### 7.1. Назначение
Offline-first backlog рядом с кодом, читается людьми и агентами, изменяется через PR.

### 7.2. Требования
- Каждая задача имеет `task_id`
- Статус `ready` означает выполнение definition_of_ready из planning profile
- Требования и PRD-ссылки живут рядом (например `DOCS/PRD/**`)

### 7.3. Рекомендации
- Выделить “execution log” отдельно (в отдельный файл или секцию), чтобы implementation PR не трогал SoT.

---

## 8. Backend: Beads (mirror backend)

### 8.1. Что такое Beads в этой модели
Beads рассматривается как **execution/memory backend**: граф задач, эпиков, связей и контекста, который помогает агентам держать долгую цепочку зависимостей и возвращаться к контексту.

Beads **не** считается источником требований в этой модели. Он является mirror backend, производным от canonical.

### 8.2. Mapping в Task Core Schema
- `task_id` — обязателен; хранится как якорь (например, в имени/метаданных beads)
- `deps` — естественно выражаются графом
- `state` — мапится на поля/статусы beads (по настройке)
- `source_ref` — ссылка на canonical WorkPlan/PRD (обязательна)

### 8.3. Правило изменений
- Любые “правки постановки” в beads считаются **предложениями**.
- Чтобы изменить canonical, инструмент должен создать Spec-Change PR (см. раздел Import/Export).
- Агент может создавать “draft” узлы/предложения в beads, но не может переводить canonical задачи в `ready`.

### 8.4. Зачем beads
- более удобная навигация по зависимостям
- “memory graph” для агентской работы
- подготовка набора issues/epics для исполнения после планирования (по желанию)

---

## 9. Import/Export и трансформации (самый важный раздел)

### 9.1. Принцип
Импорт/экспорт между backend’ами — это **трансформация**, а не ручное редактирование.

### 9.2. Правила безопасности
- Любая трансформация, меняющая canonical backend, оформляется отдельным PR типа `spec-change`.
- Этот PR требует PO/maintainer approval.
- Трансформация должна быть детерминированной и воспроизводимой (в идеале: командой в репозитории).

### 9.3. Направления
- Canonical → Mirror: разрешено автоматически/регулярно (safe).
- Mirror → Canonical: разрешено только через Spec-Change PR и аппрув.

---

## 10. Совместимость с разными стилями планирования

Этот spec намеренно не заставляет всех планировать одинаково.

Он гарантирует:
- единый минимальный язык задач (Task Core Schema),
- единый принцип правды (Canonical Backend),
- формальную декларацию стиля (Planning Profile),
- безопасные правила трансформаций (Import/Export).

Это позволяет подключать любые фреймворки (Scrum, Kanban, личные системы, агентские memory graphs) как mirrors, не ломая процесс и безопасность.

---

## 11. Связь с другими документами

- Контракт качества PR (гейты): `RFC_AI_Ready_Quality_Contract_v0.1.md`
- Workflow исполнения и обратной связи: `RFC_WorkPlan_Issues_Workflow_Protocol_v0.1.md`
- Sync WorkPlan → Issues: `SPEC_WorkPlan_to_Issues_Sync_v0.1.md`

---

## 12. Non-Goals

- выбор “лучшего” планировочного фреймворка
- реализация конкретных импортёров/экспортёров
- UX интерфейсы для планирования

---

## 13. Next steps

1) Закрепить каноничный backend (DOCS/Workplan.md vs specs/workplan.md) для Hyperprompt.  
2) Добавить `PLANNING_PROFILE` и `PLANNING_BACKENDS` в репозиторий.  
3) Описать mapping Beads → Task Core Schema в отдельном appendix, если будет реальная интеграция.

